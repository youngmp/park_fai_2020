"""
implementation of lubrication model from Fai et al 2018.

With new nondimensionalized equations.

2*pi*Rc -> 2*pi*Rp
pi*Rc**2 -> pi*Rp**2

\sim h = h/Rc -> \sim h = h/Rp
\sim z = z/Rc -> \sim z = z/Rc
\sim Q = ... -> \sim Q = 6*pi*Rp*\mu*Q/(F*(pi*Rp)*(Rc-Rp))
\sim p = ... -> \sim p = pi*Rp**2*p/F

"""

import os
import time
import numpy as np
import matplotlib.pyplot as plt

from scipy.interpolate import interp1d
from mpl_toolkits.mplot3d import Axes3D

import matplotlib as mpl
mpl.rcParams['text.usetex'] = True
mpl.rcParams['text.latex.preamble'] = [r'\usepackage{amsmath}'] 

pi=np.pi
exp=np.exp

class lubrication(object):

    def __init__(self,
                 Rp=0.96,Rc=1.22,
                 C=5e-3,mu=1.2,# confirmed with Thomas that 1.2 Pa*s is correct Nov 4, 2019. #mu=1.2e-3,
                 
                 pi3=1,pi4=4.7,pi5=0.1,pi6=None,
                 simulation_seed=0,
                 F0=None,
                 
                 phi1=0.5,
                 N=101,dt=.01,T=100,
                 constriction='circular',
                 ze=None,

                 n0=1000,
                 al=14,be=126,p1=4,gm=0.322,
                 
                 eps=1,
                 eps_dynamic=False,
                 eps_noise_scale='sqrt',
                 
                 Z0=-5,U0=1,
                 eta_fast=0,
                 eta_slow=0,
                 
                 motors=True,
                 dimensional_plots=False,
                 
                 show_manifold=False,
                 show_stable_branch=False,
                 noise='white',
                 
                 recompute_solution=False,
                 save_solution=False,
                 use_old_solution=False,
                 data_dir='~/',
                 force_pos_type='exp',

                 nondim_choice='with_attachment',
                 base_radius=3, # dimensional!
                 inner_width=5, # dimensional!
    ):


        """
        all functions (should) return nondimensional values. redimensionalization is (or rather should be) done after outputs are generated by lubrication.py.
        
        Rp veiscle radius um 0.96-1.5
        Rc channel radius um 1.22-2.15
        C compliance um/Pa. 5e-9 m/Pa
        mu fluid viscocity Pa*S
        F applied force pN 40-200
        p1,...,p6 nondimensional parameters. see appendix.

        nondim_choice: str. choose the type of nondimensionalization. Let F0 be the stall force or F0/(exp(pi4)-1).

        constriction: str. shape of the constriction. 'circular', 'piecewise', 'constant'

        integration: choose integration type. euler vs iteration.

        noise: type of noise added to the system. white noise vs poisson noise

        save_solution: save simulation data True or False
        data_dir: directory for saving generic data files

        """

        self.base_radius = base_radius
        self.inner_width = inner_width
        
        print('If you are using both dimensional and nondimensional params, nondimensional params will be used and dimensional params ignored.')
        
        self.nondim_choice = nondim_choice
        self.force_pos_type = force_pos_type
        self.ze = ze
        self.simulation_seed = simulation_seed

        self.noise = noise
        self.show_manifold = show_manifold
        self.show_stable_branch = show_stable_branch
        self.constriction = constriction

        self.eps=eps
        self.eps_noise_scale = eps_noise_scale
        self.eps_dynamic = eps_dynamic

        if self.eps_dynamic:
            print('warning: epsilon chosen to be dynamic. revert as needed')
        
        # model parameters
        self.phi1 = phi1
        self.phi2 = 1-phi1
        
        self.Rp=Rp;self.Rc=Rc;self.mu=mu        
        self.pi3=pi3;self.pi4=pi4;self.pi5=pi5

        self.al=al
        self.be=be
        self.p1=p1
        self.n0=n0
        self.gm=gm

        # dict of F0
        F0_choices = {'with_attachment':{'exp':(exp(self.pi4)-1)*self.al*self.p1*self.n0/(self.al+self.be),
                                         'lin':         self.pi4*self.al*self.p1*self.n0/(self.al+self.be)},
                      'without_attachment':{'exp':self.al*self.p1*self.n0/(self.al+self.be),
                                            'lin':self.al*self.p1*self.n0/(self.al+self.be)}}
        
        if F0 is None:

            #self.F0 = F0_choices[self.nondim_choice][self.force_pos_type]
            if self.nondim_choice == 'with_attachment':

                #self.F0 = F0_choices[self.force_pos_type]
                
                if self.force_pos_type == 'exp':
                    self.F0 = (exp(self.pi4)-1)*al*p1*n0/(al+be)
                elif self.force_pos_type == 'lin':
                    self.F0 = self.pi4*al*p1*n0/(al+be)
                else:
                    raise ValueError('Unrecognized force_pos_type', self.force_pos_type)
                    
            elif (self.nondim_choice == 'without_attachment') or (self.nondim_choice == 'no_attachment'):
                self.F0 = al*p1*n0/(al+be)

            else:
                raise ValueError('Unrecognized nondim_choice',self.nondim_choice)

                
        else:
            self.F0 = F0#self.pi3*(exp(self.pi4)-1)*p1*n0/(self.pi3+1)

        #print('pi6none?',pi6)
        if pi6 is None:
            #print('pi6none')
            self.pi6 = self.F0/(6*pi*self.Rp*self.mu)/(be/gm)
        else:
            self.pi6 = pi6

        if self.nondim_choice == 'with_attachment':
            print('using old nondim system (with force attachment)')
            self.force_factor = 1
        
        elif (self.nondim_choice == 'no_attachment') or (self.nondim_choice == 'without_attachment'):
            print('using new nondim system (without force attachment)')
            if self.force_pos_type == 'exp':
                self.force_factor = (exp(self.pi4)-1)
            elif self.force_pos_type == 'lin':
                self.force_factor = self.pi4

        else:
            raise ValueError('Unrecognized nondim_choice',self.nondim_choice) 

        
        print('pi3='+str(self.pi3)+'; pi4='+str(self.pi4)+'; pi5='+str(self.pi5)+'; pi6='+str(self.pi6))
        #print(C,F0,np.pi,Rp)
        self.C = C
        self.pi2 = C*self.F0/(np.pi*Rp**3) # dimensionless force

        # simulation parameters
        self.N = N # z discretization                
        self.z = np.linspace(-1,+1,self.N) # domain for integrals

        self.dx = (self.z[-1]-self.z[0])/(self.N)
        #self.dx=1/self.N
        self.dt = dt # time step
        self.T = T
        
        

        # nondimensionalizing
        # stokes' free law drag
        self.stokes = 6*pi*self.Rp*self.mu # units of mg/s default. multiply by 10^-6 to get Kg/s
        self.U_scale = self.F0/(self.stokes) # U (nondim) * U_scale puts velocity into um/s
        self.Z_scale = self.Rp # include another name for convenience. 
        self.tau0 = 6*pi*self.mu*self.Rp**2/self.F0 # puts time in seconds
        
        print('U_scale',self.U_scale,'F0=',self.F0,'tau0=',self.tau0)
        #print("U_scale",self.U_scale,self.F0,self.Rp,self.mu)
        
        self.zeta_inf = 6*pi*self.Rp*self.mu

        self.motors = motors

        self.pi1_min=self.Rc/self.Rp
        #slef.pi2=
        print('pi1*='+str(self.pi1_min)+', pi2='+str(self.pi2))

        self.recompute_solution = recompute_solution
        self.use_old_solution = use_old_solution
        self.save_solution = save_solution
        self.data_dir = data_dir
        
        if (not os.path.exists(self.data_dir)):
            os.makedirs(self.data_dir)
            
        self.Z0 = Z0 # initial position
        self.U0 = U0

        
        self.eta_fast = eta_fast
        self.eta_slow = eta_slow

        self.dimensional_plots = dimensional_plots
        
        # filename for data
        self.fname_prefix = 'phi1='+str(self.phi1)\
                            +'_Rp='+str(self.Rp)\
                            +'_Rc='+str(self.Rc)\
                            +'_mu='+str(self.mu)\
                            +'_pi3='+str(self.pi3)\
                            +'_pi4='+str(self.pi4)\
                            +'_pi5='+str(self.pi5)\
                            +'_pi6='+str(self.pi6)\
                            +'_F0='+str(self.F0)\
                            +'_motors='+str(self.motors)\
                            +'_C='+str(self.C)\
                            +'_pi1_max'+str(self.pi1_min)\
                            +'_pi2'+str(self.pi2)\
                            +'_N='+str(self.N)\
                            +'_dt='+str(self.dt)\
                            +'_T='+str(self.T)\
                            +'_eta_fast='+str(self.eta_fast)\
                            +'_eta_slow'+str(self.eta_slow)\
                            +'_eps='+str(self.eps)\
                            +'_eps_dynamic='+str(self.eps_dynamic)
                            #+''+str()\
                            #+''+str()\

        self.sol_fname = './'+self.data_dir+'/'+self.fname_prefix+'.dat'

        #print(self.data_dir)
        # manifold flags
        self.manifold_created = False
        if self.show_manifold:
            self.get_manifold()
        

    def FA_neg(self,u):
        """
        Force for F_A, U < 0
        """
            
        return -self.force_factor*( 1+self.pi6*u*(exp(self.pi4)-1)**(-1) )/( 1-self.pi6*u )

    def FA_pos(self,u):
        """
        Force for F_A, U >= 0
        """
        #print(u)
        ep4 = exp(self.pi4)
        ep5 = exp(self.pi5)
        p56 = self.pi5/self.pi6

        return -self.force_factor*((self.pi3+1)/(self.pi3*(1-exp(-p56/u))+1)) *( ep4*( 1-ep5*exp(-p56/u) )-(1-self.pi6*u)*(1-exp(-p56/u)) )/((1-self.pi6*u)*(ep4-1))


    def FA(self,u):
        """
        force-velocity curve for motor attachment at z=A and vesicle movement in the -z direction
        
        u: dimensional velocity input U
        """
        
        # scalars and arrays must be treated differently since inequalities don't play well with arrays.
        u = np.asarray(u)
        
        u_neg = u[u<0]
        u_pos = u[u>0]
        u_zer = u[u==0]
        
        F = np.zeros(np.shape(u))
        
        F[u<0] = self.FA_neg(u_neg)
        F[u>0] = self.FA_pos(u_pos)
        F[u==0] = -1


        return F
        
    def FAm_neg(self,u):
        """
        Force for F_A, U < 0
        """
        #p6u =

        #print(u)
        ep4 = exp(self.pi4)
        ep5 = exp(self.pi5)
        p56 = self.pi5/self.pi6

        return self.force_factor*((self.pi3+1)/(self.pi3*(1-exp(p56/u))+1)) *( ep4*( 1-ep5*exp(p56/u) )-(1+self.pi6*u)*(1-exp(p56/u)) )/((1+self.pi6*u)*(ep4-1))
    

    def FAm_pos(self,u):
        """
        Force for F_A, U >= 0
        """
        
        return self.force_factor*( 1-self.pi6*u*(exp(self.pi4)-1)**(-1) )/( 1+self.pi6*u )
    
    def FAm(self,u):
        """
        force-velocity curve for competing motor attachment at z=-A, detachment at z=-B. 
        
        u: nondimensional velocity input U
        """

        u = np.asarray(u)
        u_neg = u[u<0]
        u_pos = u[u>=0]
            
        F = np.zeros(np.shape(u))
        
        F[u<0] = self.FAm_neg(u_neg)
        F[u>=0] = self.FAm_pos(u_pos)


        return F

    def FA_linear_neg(self,x):
        """
        F(U)_{A}, U<=0, verified correct nov 18, 2019. see force_new_nondim_linear.nb
        """

        return -self.force_factor*(x*self.pi6 + self.pi4)/self.pi4


    def FA_linear_pos(self,x):
        """
        F(U)_{A}, U>0, verified correct Nov 18, 2019. see force_new_nondim_linear.nb
        """

        p3 = self.pi3
        p4 = self.pi4
        p5 = self.pi5
        p6 = self.pi6
        
        ep56 = exp(-p5/(x*p6))

        return -self.force_factor*(p3+1)/( p3*(1-ep56)+1 ) * (x*p6+p4-ep56*(x*p6+p5+p4))/p4

        
    def FA_linear(self,u):
        """
        FV curve assuming linear force-position
        """
        
        u = np.asarray(u)
        u_neg = u[u<0]
        u_pos = u[u>=0]
            
        F = np.zeros(np.shape(u))
        
        F[u<0] = self.FA_linear_neg(u_neg)
        F[u>=0] = self.FA_linear_pos(u_pos)
        
        return F

    
    def F(self,x):
        """
        net force function, nondimensionalized
        """


        
        if self.force_pos_type == 'exp':
            
            return self.phi1*self.FAm(x)+self.phi2*self.FA(x)

        elif (self.force_pos_type == 'linear') or (self.force_pos_type == 'lin'):

            return -self.phi1*self.FA_linear(-x)+(1-self.phi1)*self.FA_linear(x)

        else:
            raise Exception('Unrecognized FV type',self.force_pos_type)


    def DFp_pos(self,U):
        U = np.asarray(U)
        
        return -(((1+self.pi3)*(exp(self.pi4+self.pi5)*self.pi3*self.pi6**2*U**2+exp(self.pi4+(2*self.pi5)/(self.pi6*U))*(1+self.pi3)*self.pi6**2*U**2+exp(self.pi5/(self.pi6*U))*self.pi5*(-1+self.pi6*U)**2+exp(self.pi4+self.pi5+self.pi5/(self.pi6*U))*(1+self.pi3)*(-(self.pi6**2*U**2)+self.pi5*(-1+self.pi6*U))-exp(self.pi4+self.pi5/(self.pi6*U))*self.pi3*(self.pi6**2*U**2+self.pi5*(-1+self.pi6*U))))/((-1+exp(self.pi4))*(self.pi3-exp(self.pi5/(self.pi6*U))*(1+self.pi3))**2*self.pi6*U**2*(-1+self.pi6*U)**2))

    def DFp_neg(self,U):
        U = np.asarray(U)
        return -((exp(self.pi4)*self.pi6)/((-1 + exp(self.pi4))*(-1 + self.pi6*U)**2))

    def DFm_pos(self,U):
        U = np.asarray(U)
        return -((exp(self.pi4)*self.pi6)/((-1 + exp(self.pi4))*(1 + self.pi6*U)**2))

    def DFm_neg(self,U):
        U = np.asarray(U)
        return -(((1+self.pi3)*(exp(self.pi4+self.pi5+(2*self.pi5)/(self.pi6*U))*self.pi3*self.pi6**2*U**2+exp(self.pi4)*(1+self.pi3)*self.pi6**2*U**2+exp(self.pi5/(self.pi6*U))*self.pi5*(1+self.pi6*U)**2+exp(self.pi4+self.pi5/(self.pi6*U))*self.pi3*(self.pi5+self.pi5*self.pi6*U-self.pi6**2*U**2)-exp(self.pi4+self.pi5+self.pi5/(self.pi6*U))*(1+self.pi3)*(self.pi5+self.pi5*self.pi6*U+self.pi6**2*U**2)))/((-1+exp(self.pi4))*(-1+(-1+exp(self.pi5/(self.pi6*U)))*self.pi3)**2*self.pi6*U**2*(1+self.pi6*U)**2))
 
    def DFp(self,u):

        u = np.asarray(u)
        
        u_neg = u[u<0]
        u_pos = u[u>=0]
        
        DF = np.zeros(np.shape(u))
        
        DF[u<0] = self.DFp_neg(u_neg)
        DF[u>=0] = self.DFp_pos(u_pos)
        
        return DF

    def DFm(self,u):
        u = np.asarray(u)
        
        u_neg = u[u<0]
        u_pos = u[u>=0]
        
        DFm = np.zeros(np.shape(u))
        
        DFm[u<0] = self.DFm_neg(u_neg)
        DFm[u>=0] = self.DFm_pos(u_pos)
        
        return DFm

    def DF(self,x):
        x = np.asarray(x)
        #print('phi1,phi2',self.phi1,self.phi2)
        return self.phi1*self.DFm(x) + self.phi2*self.DFp(x)
    
    def pi1(self,x,r=10,d=False):
        """
        channel bump. one of the few dimenisonal functions in this class. need to rescale inputs and outputs if working in lubrication

        x: scalar, absolute z coordinate. input is nondimensional when used in lubrication. so need to make sure to convert.

        r: radius of circle, should be much bigger than Rc according to fig 1c
        
        left side/upper side of circle must touch the center of vesicle for Rc=0
        """


        # want the channel start at -5um and end at 5um. so bounds must be converted.
        # channel start is at 5um/Rp
        

        x = np.asarray(x)
        y = np.zeros(len(x))
        
        if self.constriction == 'circular':

            if d: # if derivative flag, return derivative
                y[(x<=-5)] = 0
                y[(x>=5)] = 0
                y[(x>-5)*(x<5)] = x[(x>-5)*(x<5)]/np.sqrt(r**2-x[(x>-5)*(x<5)]**2)
                
                
            
            else:
                y[(x<=-5)] = (r+self.Rc)-np.sqrt(r**2-(-5)**2)
                y[(x>=5)] = (r+self.Rc)-np.sqrt(r**2-(-5)**2)
                y[(x>-5)*(x<5)] = (r+self.Rc)-np.sqrt(r**2-x[(x>-5)*(x<5)]**2)
#                

        elif self.constriction == 'constant':
            y = self.Rc*np.ones(len(x))

        elif self.constriction == 'piecewise':
            y[(x<=-5)] = self.base_radius
            y[(x>=5)] = self.base_radius


            # line down to minimal Rc
            x_line_down = (x>-5)*(x<-self.inner_width/2.)
            m = (self.Rc-self.base_radius)/(-5+self.inner_width/2-(-5))
            b = self.base_radius - m*(-5)
            y[x_line_down] = m*x[x_line_down]+b

            # Rc
            y[(x>-self.inner_width/2.)*(x<self.inner_width/2.)] = self.Rc

            # line up from Rc to self.base_radius
            x_line_up = (x<5)*(x>self.inner_width/2.)
            m = (self.Rc-self.base_radius)/(5-self.inner_width/2-5)
            b = self.base_radius - m*(5)
            y[x_line_up] = m*x[x_line_up]+b


        return y
    
    def viscous_drag(self,Z):
        """
        viscous drag zeta as a function of position Z
        """

        if not(self.ze == None):
            return self.ze
        else:

            h = self.pi1((Z+self.z)*self.Rp)/self.Rp - np.sqrt( np.abs(1-(self.z)**2) )
            
            if False:
                print('Z',Z)
                fig = plt.figure()
                ax = fig.add_subplot(111)
                ax.plot(self.z,h)
                #ax.plot(self.z,h**(-2)+h**(-3))
                plt.show()
            
            return np.sum(h**(-2)+h**(-3),axis=-1)*self.dx

    def dy(self,y,t,**kwargs):
        U = y[0]
        Z = y[1]

        if 'zeta' in kwargs:
            zeta = kwargs['zeta']
            eps = zeta*self.dt
            
        else:
            zeta = self.viscous_drag(Z)
            eps = self.eps

        return np.array([(self.F(U) - U*zeta)/self.eps,U])

    def check_boundary(self,sol):
        """
        if the solution hits a boundary, reset.
        sol should be 2 element array. [velocity, position].

        only non-negative velocities are allowed at the base of the channel and only nonpostive velocities are allowed at the end of the channel.
        """

        # boundary conditions # boundary conditions are set in dmensional units
        if sol[1]*self.Z_scale < -5:
            sol[1] = -5/self.Z_scale # position
            #if sol[0] < 0:
            #    sol[0] = 0 # velocity
            
        if sol[1]*self.Z_scale >= 5:
            sol[1] = 5/self.Z_scale
            if sol[0] > 0:
                sol[0] = 0
            
        return sol

    def noise_vector(self,eps):

        if self.noise == 'white':
            
            xi_fast = np.random.normal(loc = 0.0, scale = np.sqrt(self.dt))
            xi_slow = np.random.normal(loc = 0.0, scale = np.sqrt(self.dt))

            noise_vector = np.array([self.eta_fast*xi_fast,
                                     self.eta_slow*xi_slow])

            if self.eps_noise_scale == '1/sqrt(eps)':
                noise_vector /= np.sqrt(eps)
                
            elif self.eps_noise_scale == '1/eps':
                noise_vector /= eps
        
        return noise_vector

    def run_sim(self):
        """
        make decisions about whether or not to run sim (or load solution data) here.
        """

        
        file_not_found = False
        leave_menu = False

        #self.sol = np.zeros((1,2))

        #print(self.sol_fname)
        #print(os.path.isfile(self.sol_fname))
        
        while not(leave_menu):
            
            if self.recompute_solution or file_not_found or not(self.use_old_solution):
                """
                force recomputation of LC
                """

                self.TN = int(self.T/self.dt)
                self.U = np.zeros(self.TN)
                self.Z = np.zeros(self.TN)
                self.t = np.linspace(0,self.T,self.TN)


                if self.eta_fast == 0 and self.eta_slow == 0:
                    self.run_euler()
                else:
                    self.run_euler() # contains self.lc_data

                if self.save_solution:
                    np.savetxt(self.sol_fname,self.sol)
                
                leave_menu = True

            else:
                
                if os.path.isfile(self.sol_fname):
                    self.sol = np.loadtxt(self.sol_fname)

                    leave_menu = True
                    
                else:
                    file_not_found = True
            
        # define explicit arrays for velocity and position for convenience
        self.U = self.sol[:,0]
        self.Z = self.sol[:,1]            
        
    def run_euler(self):
        
        np.random.seed(self.simulation_seed)

        # preallocate
        self.sol = np.zeros((len(self.t),2)) # column 1 is U, column 2 is Z'
        self.zeta = np.zeros(len(self.t))

        # initial velocity and position
        self.sol[0,0]=self.U0; self.sol[0,1]=self.Z0


        self.switch_times = []
        side = 0
        
        i = 0 # counter for time

        

        while (self.t[i] < self.t[-1]):
            #print(self.sol[i,0],self.t[i])

            
            # if epsilon = zeta*dt, the function needs to be called differently.
            # we might remove this option in the future
            if self.eps_dynamic:
                zeta = self.viscous_drag(self.sol[i,1])
                eps = zeta*self.dt
                f = self.dy(self.sol[i,:],self.t[i],zeta=zeta)

            else:
                eps = self.eps
                f = self.dy(self.sol[i,:],self.t[i])

            # update solution
            noise = self.noise_vector(eps)            
            self.sol[i+1,:] = self.sol[i,:]+ self.dt*f + noise

            if (side == 0) and (self.sol[i+1,0]*self.U_scale >= 200):
                side = 1
                self.switch_times.append(self.t[i])

            if (side == 1) and (self.sol[i+1,0]*self.U_scale <= -200):
                side = 0
                self.switch_times.append(self.t[i])

            self.zeta[i+1] = self.viscous_drag(self.sol[i,1])
            # force boundary conditions
            self.sol[i+1,:] = self.check_boundary(self.sol[i+1,:])

            i += 1
        
    def get_stable_branch(self,phi1,zeta):
        """
        estimate on the velocity of the stable branch
        """
        return 4*(self.phi1-0.5)*(2*exp(self.pi4)*self.pi6/(exp(self.pi4)-1)+zeta)**(-1)

    def get_manifold(self):

        self.manifold_created = True
                
        M = 200 # velocity 
        
        #z = np.linspace(-1,+1,N) # position domain
        
        ##### critical manifold
        U = np.linspace(-.2,.2,M) # velocity range
        Z = np.linspace(-5,5,M) # position range
        Zm,Um = np.meshgrid(Z,U)
        ze = np.zeros((M,M))
        h = np.zeros((M,M,self.N))
        
        for i in range(M):
            for j in range(M):
                #h = self.pi1(Z+self.z)/self.Rp - np.sqrt( np.abs(1-(self.z)**2) )    
                #h[i,j,:] = self.pi1(Zm[i,j]+self.z)/self.Rp - np.sqrt( np.abs(1-(self.z)**2) )
                #h[i,j,:] = self.viscous_drag(Zm[i,j])
                ze[i,j] = self.viscous_drag(Zm[i,j])

        #ze = (np.sum(h**(-2),axis=-1) + np.sum(h**(-3),axis=-1))*self.dx#/self.N
        C_0 = self.F(Um)-ze*Um # critical manifold

        if False:
            fig = plt.figure()
            ax = fig.add_subplot(111)
            ax.set_title('lub')
            ax.contourf(ze)
            plt.show()
            plt.close()
        
        fig = plt.figure()
        ax1 = fig.add_subplot(111)
        ax1_contour = ax1.contour(Zm,Um,C_0,[0])
        
        p = ax1_contour.collections[0].get_paths()

        self.C0_x_list = []
        self.C0_y_list = []
        
        for paths in p:
            
            v = paths.vertices
            
            self.C0_x_list.append(v[:,0])
            self.C0_y_list.append(v[:,1])
            
        #plt.show()
        plt.close()

        
    def psi(self,x,domain,zeta):
        """
        function psi, used in probability/first passage time problems, defined in Gardiner, for convenience.

        x: domain vector
        zeta: scalar
        """

        dx = (domain[-1]-domain[-2])/len(domain)
        f = exp(2/self.eta_fast*np.cumsum(self.F(domain)-zeta*domain)*dx)
        
        return interp1d(domain,f)(x)


    
    def pi_a(self,x,domain,zeta,d=False):
        """
        function pi_a, probability of escale through (lower) boundary a
        """

        
        if d:
            return -self.pi_b(x,domain,zeta,d=True)
        else:
            return 1 - self.pi_b(x,domain,zeta)
        
        
    def pi_b(self,x,domain,zeta,d=False):
        
        dx = (domain[-1]-domain[-2])/len(domain)
        tot = np.sum(self.psi(domain,domain,zeta))*dx
        f = np.cumsum(self.psi(domain,domain,zeta))*dx

        #print(len(domain),len(f),x)
        if d:
            #print(self.psi(x,domain,zeta))
            return self.psi(x,domain,zeta)/tot
        else:
            return interp1d(domain,f)(x)/tot

    
    def mfpt_ode(self,y,t,domain=np.zeros(1),zeta=0):
        """
        for the calculation of mean first passage time
        2nd order ode
        """
        
        y1 = y[0]
        y2 = y[1]

        dx = (domain[-1]-domain[-2])/len(domain)
        tot = np.sum(self.psi(domain,domain,zeta))*dx
        
        #print(self.psi(t,domain,zeta),tot,-self.pi_b(t,domain,zeta,d=True),self.pi_a(t,domain=domain,zeta=zeta,d=True),(self.eta_fast*self.pi_a(t,domain=domain,zeta=zeta)))

        A = self.F(t)-zeta*t
        pi_a = self.pi_a(t,domain=domain,zeta=zeta)
        dpi_a = self.pi_a(t,domain=domain,zeta=zeta,d=True)

        B = self.eta_fast
        
        return np.array([y2,2*(-pi_a-2*y1-(A*pi_a + B*dpi_a)*y2)/(B*dpi_a)])

    def run_mfpt(self):

        # pick a zeta parameter. pi_a,b, psi will be computed once for a given zeta, then recomputed (without history) for another zeta.
        self.zeta_par = 1
        self.x_test = np.linspace(-9e-2,9e-2,201)

        dx = (self.x_test[-1]-self.x_test[-2])/len(self.x_test)

        self.mfpt = np.zeros((len(self.x_test),2))

        zeta = 1

        for i in range(len(self.x_test)-1):
            t = self.x_test[i]

            self.mfpt[i+1,:] = self.mfpt[i,:] + dx*self.mfpt_ode(self.mfpt[i,:],t,domain=self.x_test,zeta=self.zeta_par)
        
    
    def plot(self,choice='Z'):

        fig = plt.figure()
        
        if choice == 'Z':

            fig.set_figwidth(5)
            fig.set_figheight(10)
            

            ax1 = fig.add_subplot(311)
            ax2 = fig.add_subplot(312)
            ax3 = fig.add_subplot(313)

            #

            #ax1.hist(self.U[:]*self.U_scale,bins=100)
            #ax1.set_xlabel('V')
            #ax1.set_ylabel('V count')

            #ax1.set_title('phi1='+str(self.phi1)+', euler')

            if self.dimensional_plots:
                t = self.t[:]*self.tau0
                u = self.U[:]*self.U_scale
                z = self.Z[:]*self.Rp

                xlabel = r'$t$ (s)'
                ylabel_v = 'Velocity (um/s)'
                ylabel_z = 'Z (um)'
                
            else:
                t = self.t[:]
                u = self.U[:]
                z = self.Z[:]

                
                xlabel = r'$t/\tau_0$'
                ylabel_v = 'Velocity nondim'
                ylabel_z = 'Z (um)'


            ax1.plot(t,z)
            ax1.set_xlabel(xlabel)
            ax1.set_ylabel(ylabel_z)

            ax2.plot(t,u)
            ax2.set_xlabel(xlabel)
            ax2.set_ylabel(ylabel_v)            

            x = np.linspace(-10,10,40)
            x2 = np.linspace(0,2*pi,20)

            ax3.plot(.96*np.cos(x2),.96*np.sin(x2))
            ax3.plot(x,self.pi1(x)/self.Rp)

            ax3.set_xlabel('z-distance from center of constricion')
            ax3.set_ylabel('constriction profile')

            
            if self.eps_dynamic:
                eps_label = ''#'; eps_dynamic='+str(self.eps_dynamic)
            else:
                eps_label = ''

            if self.eta_fast > 0:
                noise_label = r'; $\eta_\text{fast}='+str(self.eta_fast)+r'$'
            else:
                noise_label = r'; $\epsilon='+str(self.eps)+r'$'

            ax3.set_title(r'$R_p='+str(self.Rp)+r'$; $R_c='+str(self.Rc)+r'$; $F_0='+str(self.F0)+r'$; $\pi_5='+str(self.pi5)+r'$'+noise_label+eps_label)

            plt.tight_layout()

        elif choice == 'psi':

            #for key in fig.__dict__:
            #    print(key,fig.__dict__[key])
            #plt.close()
            #fig = plt.figure(figsize=(6,2))
            #fig.figsize(6,2)

            fig.set_figheight(3)
            fig.set_figwidth(8)
            
            ax1 = fig.add_subplot(141)
            ax2 = fig.add_subplot(142)
            ax3 = fig.add_subplot(143)
            ax4 = fig.add_subplot(144)

            self.run_mfpt()
            
            zeta = 1

            ax1.plot(self.x_test,self.psi(self.x_test,self.x_test,zeta))
            ax2.plot(self.x_test,self.pi_a(self.x_test,self.x_test,zeta))
            ax3.plot(self.x_test,self.pi_b(self.x_test,self.x_test,zeta))
            ax4.plot(self.x_test,self.mfpt[:,0])

            ax1.set_title(r'$\psi(x)$')
            ax2.set_title(r'$\pi_a(x)$')
            ax3.set_title(r'$\pi_b(x)$')

            ax2.set_xlabel(r'$x$')
            ax2.set_xlabel(r'$x$')
            
            ax2.set_ylabel('Probably of Escape (Left)')
            ax3.set_ylabel('Probably of Escape (Right)')
            ax4.set_ylabel('MFPT (Left)')
            

            plt.tight_layout()

        elif choice =='zu':
            #print(self.Z0,self.U0)

            ax = fig.add_subplot(111)

            if self.show_manifold:
                ax.set_title('$R_p='+str(self.Rp)+'$, $R_c='+str(self.Rc)+'$, $\phi_1='+str(self.phi1)+'$, $\pi_5='+str(self.pi5)+'$')
                
                for i in range(len(self.C0_x_list)):
                    
                    ax.plot(self.C0_x_list[i],self.C0_y_list[i],color='gray',label='slow manifold')

            if self.show_stable_branch:

                z_temp = np.linspace(-5,5,100)
                zeta_temp = np.zeros(len(z_temp))

                for i in range(len(z_temp)):
                    zeta_temp[i] = self.viscous_drag(z_temp[i])
                
                ax.plot(z_temp,self.get_stable_branch(self.phi1,zeta_temp),label='stable branch',ls='--')
                
            #print(self.Z[0],self.U[0])
            ax.plot(self.Z,self.U,lw=2,color='r')

            ax.set_xlabel('$Z$')
            ax.set_ylabel('$U$')

            ax.set_xlim(-5,5)


        elif choice == 'manifold':
            
            ax = fig.add_subplot(111)

            if self.manifold_created == False:
                self.get_manifold()
            
            for i in range(len(self.C0_x_list)):
                ax.set_title('Rp='+str(self.Rp)+', Rc='+str(self.Rc)+', phi1='+str(self.phi1))
                ax.plot(self.C0_x_list[i],self.C0_y_list[i],color='gray')

            ax.set_xlim(-5,5)                
        
        elif choice == 'pi1':
            x = np.linspace(-5,5,100)

            ax = fig.add_subplot(111)
            ax.plot(x,self.pi1(x))
            

        elif choice == 'rhs':

            
            fig.set_figheight(3)
            fig.set_figwidth(6)

            u = np.linspace(-1,1,1000)

            ax = fig.add_subplot(121)
            ax2 = fig.add_subplot(122)
            #print(self.__dict__)
            #ax.plot(u,self.phi1*self.FAm(u) + self.phi2*self.FA(u)-self.zeta*u,lw=2)
            
            print('type',self.force_pos_type)
            #ax.plot(u,self.F(u)-self.ze*u,lw=2)
            #ax.plot(u,self.FA(u),lw=2)

            if self.force_pos_type == 'lin' or self.force_pos_type == 'linear':
                ax.plot(u,self.FAm_linear(u),lw=2)
                ax.plot(u,-self.FAm_linear(-u),lw=2)
                ax.plot(u,self.FAm_linear(u)-self.FAm_linear(-u),lw=2)

                ax2.plot(u,.5*(self.FAm_linear(u)-self.FAm_linear(-u))-0*u,lw=2)

            else:
                ax.plot(u,self.FAm(u),lw=2)
                ax.plot(u,-self.FAm(-u),lw=2)
                ax.plot(u,self.FAm(u)-self.FAm(-u),lw=2)

                ax2.plot(u,.5*(self.FAm(u)-self.FAm(-u))-0*u,lw=2)
                #ax.plot(u,self.F(u)-self.zeta[int(len(self.zeta)/2)]*u,lw=2,label=str(self.zeta[int(len(self.zeta)/2)]))
                
            #ax.plot(u,self.F(u)-self.zeta[-1]*u,lw=2,label=str(self.zeta[-1]))
            #ax.plot(u,self.F(u)-self.zeta[-1]*u,lw=2)
            ax.plot([u[0],u[-1]],[0,0],color='k',lw=.5)
            

            ax.set_xlim(u[0],u[-1])
            #ax.set_ylim()

            ax.set_xlabel(r'$\tilde U$')
            ax.set_ylabel(r'$\tilde F$')

            #ax.set_title(r'$\phi_1='+str(self.phi1)+r'$; $\zeta=beginng, middle, end')

            ax.legend()
            
        elif choice == 'zeta':

            
            ax1 = fig.add_subplot(111)
            ax1.set_title(r'$\tilde \zeta(t)$')
            
            if self.dimensional_plots:
                t = self.t*self.tau0
                ze = self.zeta*6*pi*self.Rp*self.mu
                #ax1.plot(self.t,self.zeta*6*pi*self.Rp*self.mu)
                xlabel='t (s)'
                ylabel='Drag (mg/s)'
                #title
            else:
                t = self.t
                ze = self.zeta
                xlabel=r'$t/\tau_0$'
                ylabel='Nondimensional Drag'

            ax1.plot(t,ze)
            ax1.set_xlabel(xlabel)
            ax1.set_ylabel(ylabel)

        elif choice == 'Z_distribution':
            
            ax = fig.add_subplot(111)
            
            ax.hist(self.Z,bins=25)

            ax.set_title(r'$U$ Distribution')

        elif choice == 'U_distribution':

            ax = fig.add_subplot(111)

            ax.hist(self.U,bins=25)

            ax.set_title(r'$Z$ Distribution')


            
def main():

    # with eps_dynamic = True, eta_fast = 2.15e-2 seems to work to reproduce fai et al 2017.
    # here, the lowest eta_fast value is approximately 0.00885 == 8.85e-3
    
    a = lubrication(T=1,dt=.002,
                    Z0=-5,U0=.5,
                    Rp=0.96,Rc=1.22,
                    #Rp=1.5,Rc=2.15,

                    #pi3=1./9,pi4=1.61,pi5=0.161,
                    #pi3=1,pi4=4.7,pi5=.1,pi6=10,
                    
                    #pi3=1,pi4=4.7,pi5=.0025,pi6=10,

                    pi3=.01,pi4=4.7,pi5=.1,pi6=10,
                    
                    n0=200,
                    F0=50,
                    #ze=0.0,
                    
                    phi1=.56,#pi5=0.1,
                    #eta_fast=7.9e-4,eta_slow=0,
                    #eta_fast=.008,eta_slow=0,
                    eta_fast=0,eta_slow=0,
                    
                    eps_noise_scale='1/eps',#'1/sqrt(eps)',
                    eps=0.1,
                    eps_dynamic=False, #1.35e-2
                    
                    mu=1.2,
                    constriction='piecewise',motors=True,dimensional_plots=False,
                    show_manifold=True,
                    
                    show_stable_branch=False,
                    save_solution=False,
                    use_old_solution=False,
                    recompute_solution=False,
                    force_pos_type='exp',
                    #nondim_choice='without_attachment',
                    nondim_choice='without_attachment',
    )
    
    #a.run_iteration()

    t = time.time()
    
    a.run_sim()
    elapsed = time.time()-t
    print('total euler run time',elapsed)

    print('std',np.std(a.U*a.U_scale),'mean',np.mean(a.U*a.U_scale))
    
    #a.plot('zu')
    #a.plot('Z')
    a.plot('Z')

    
    
    #a.plot('Z_distribution')
    #a.plot('U_distribution')

    #a.plot('psi')

    
    #a.run_slow()
    #a.plot('manifold')
    
    a.plot('zeta')
    a.plot('rhs')
    a.plot('pi1')
    plt.show()
    

if __name__ == "__main__":
    main()




